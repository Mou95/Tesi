% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Progettazione}
\label{cap:progettazione}

La progettazione nel caso del prodotto che dovevo sviluppare si è concentrata particolarmente sulla piattaforma di api.ai, in quanto rappresentava la maggior parte del lavoro. Successivamente sono passato alla progettazione delle classi da introdurre nel codice già creato dall'azienda, per gestire le nuove funzionalità del \gls{chatbot}.

\section{Studio di api.ai}
Prima di passare all'attività di progettazione è stato fondamentale analizzare e studiare a fondo le possibilità che api.ai mette a disposizione per la creazione del prodotto a me richiesto. I concetti base per capire il funzionamento di api.ai sono quattro:
\begin{itemize}
	\item \textbf{agent}: gli \emph{agents} sono meglio descritti come moduli NLU (Natural Language Understanding). Questi possono essere inclusi nell'applicazione, nel prodotto o nel servizio e trasformano le richieste di utenti naturali in dati attivi. Questa trasformazione si verifica quando un input utente corrisponde a uno degli \emph{intent} all'interno dell'\emph{agent};
	\item \textbf{intent}: sono una mappatura tra quello che l'utente può scrivere in input e l'azione che il software deve intraprendere. Un intent è formato dalle seguenti sezioni:
	\begin{itemize}
		\item\textbf{ \emph{user says}}: perché l'\emph{agent} capisca la domanda, sono necessari esempi di come la stessa domanda può essere posta in modi diversi. Lo sviluppatore aggiunge queste permutazioni alla sezione \emph{user says} dell'\emph{intent}. Più variazioni vengono aggiunte all'\emph{intent}, meglio l'\emph{agent} comprenderà l'utente;
		\item \textbf{\emph{action}}: contiene il nome della \emph{action}, che può essere utilizzato per attivare una particolare funzione del prodotto, e la tabella dei \textbf{\emph{parameters}}. I parameters possono gli elementi che collegano le parole nelle \emph{user says} alle \emph{entities};
		\item \textbf{\emph{response}}: in questa sezione è possibile definire la risposta di api.ai quando l'\emph{intent} viene attivato. Non è stato quasi mai utilizzato, in quanto la risposta all'utente veniva generata nella \emph{business logic}.
	\end{itemize}
	\item \textbf{context}: i \emph{context} rappresentano il contesto corrente della richiesta di un utente. Ciò è utile per differenziare frasi che possono essere vaghe o avere significati diversi a seconda delle preferenze dell'utente, della posizione geografica, della pagina corrente di un'applicazione o dell'argomento della conversazione. È possibile impostare un \emph{lifespan} ad ognuno di essi per definire dopo quante richieste il \emph{context} deve scadere;
	\item \textbf{entity}: le entities sono strumenti potenti utilizzati per estrarre i valori dei parametri dagli input degli utenti. Tutti i dati importanti che si desidera ottenere dalla richiesta di un utente, avranno un'entità corrispondente. Le \emph{system entities} sono entità pre-costruite fornite da API.AI per facilitare la gestione dei più comuni concetti (luoghi, orari, colori, ecc..). È possibile poi definire le proprie \emph{entities} in base alle necessità dello sviluppatore;
\end{itemize}


\section{Progettazione agents api.ai}
Durante la progettazione degli \emph{agents} per api.ai è stato necessario definire tutti gli \emph{intents} utili a soddisfare i requisiti definiti durante l'analisi dei requisiti. Il passo successivo è stato quello di progettare le \emph{user says} per ogni \emph{intent} e le relative \emph{entity}.

\subsubsection{Gestore di eventi}
Per quanto riguarda la progettazione del \gls{chatbot} dedicato alla gestione di eventi, sono stati definiti le seguenti categorie di \emph{intents} (uno per ogni possibile domanda di natura diversa):
\begin{itemize}
	\item \textbf{durata delle conferenze}: questo intent servirà per fornire all'utente la durata della conferenza da lui richiesta;
	\item \textbf{orario delle conferenze}: questo intent servirà per fornire all'utente l'orario di inizio e fine delle conferenze;
	\item \textbf{orario delle conferenze}: 
\end{itemize}

\begin{center}
\begin{longtable}{|c|>{\centering}m{7cm}|c|}
\hline
\textbf{Nome} & \textbf{Entities principali} & \textbf{Domande possibili}\\
\hline
\endhead
Durata conferenza &  Nome della conferenza & \emph{"Quanto dura la conferenza X?"}\\ \hline
\caption[Requisiti Funzionali]{Requisiti Funzionali}
\label{tabella:req0}
\end{longtable}
\end{center}



\section{Jaro Winkler distance}
Durante l'attività di progettazione mi sono reso conto come fosse necessario gestire un possibile errore di scrittura dell'utente in una delle sue domande, soprattutto nelle parole fondamentali per formulare le risposte, come ad esempio il nome di un comune per il \gls{chatbot} del meteo o il nome di una conferenza in quello degli eventi. In un primo momento infatti l'input dell'utente veniva utilizzato direttamente nelle \emph{query SQL} per interrogare il database ed ottenere i dati di interesse, soprattutto attraverso l'operatore \emph{"LIKE"}. In questo modo però non è possibile gestire il caso in cui un utente scriva ad esempio il comune "Padvoa", intendendo Padova. \\
Per ovviare a questo problema quindi è stato deciso di introdurre, dopo uno studio delle possibili soluzioni, la Jaro Winkler distance\footcite{jaro}, ossia una metrica che misura la "distanza" tra due stringhe per capire quanto esse siano simili tra loro. Grazie a questa accortezza, nel caso di errore di scrittura, il \gls{chatbot} è in grado di:
\begin{itemize}
	\item fornire una serie di opzioni di cosa secondo lui l'utente voleva scrivere, dando la possibilità ad esso di selezionare quella giusta;
	\item fornire i dati richiesti dall'utente nel caso ci sia un'unica corrispondenza simile a quanto scritto dall'utente nel database.
\end{itemize}